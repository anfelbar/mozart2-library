#!/usr/bin/perl
#
# $Id$
#
# Generate Oz constant declarations and definitions from GTK header files
#
# Author:
# Andreas Simon <asimon@ps.uni-sb.de>
#
# Copyright:
# Andreas Simon (1999)


@gtk_headers      = </usr/include/glib.h /usr/include/gtk/gtk*.h>;

$declaration_file = "constdeclarations.oz";
$definition_file  = "constdefinitions.oz";

sub remove_comments {
    s/\/\*[^\/]*\*\///g;
}

sub enum_to_hash($$) {
    # @_[0] is the name of the enumeration
    # @_[1] is the body of a enumeration
    # output is a hash of the key/value pairs

    my($enum_name, $body) = @_;
    my $i;
    my $name;
    my $value;
    my @values;
    my %hash;

    $hash{"enum"} = $enum_name;

    $body =~ s/[ \t\r\f]//g;   # remove spaces
    $body =~ s/,$//gm;         # remove colons
    $body =~ s/^\n//mg;        # remove blank lines

    $i = 0;
    @values = split /\n/, $body;
    foreach $name (@values) {
        if($name =~ m/=/g) {
            $value = $name;
            $value =~ s/^(\w+)=//g; # cut name
            # compute the right value
            if ($value =~ m/1<<(\d+)/) {                    # a << b
                $value = 2 ** $1;
            } elsif ($value =~ m/\'(.)\'/) {                # 'a'
                $value = ord $1;
            } elsif ($value =~ m/[\s\(]*(\w+)\|(\w+)/) {    # a | b
                $value = $hash{$1} | $hash{$2};
            }
        }else {
            $value = $i;
        }
        $name  =~ s/=.*$//g;  # remove asignments
        $name  =~ s/[ \t]//g; # remove unnessesary spaces

        $hash{$name} = $value;
        $i = ++$value
    }
    return \%hash;
}

sub gen_declarations(\%) {
    my ($hash)    = @_;
    my $oz_phrase = "\% enum " . $$hash{"enum"} . "\n";
    my $name;

    foreach $name (keys %$hash) {
        # just discard the values
        $oz_phrase = $oz_phrase . "$name\n" if $name !~ m/enum/;
    }
    return "$oz_phrase\n";
}

sub gen_definitions(\%) {
    my ($hash)    = @_;
    my $oz_phrase = "\% enum " . $$hash{"enum"} . "\n";
    my $name;

    foreach $name (keys %$hash) {
        $oz_phrase = $oz_phrase . "$name = $$hash{$name}\n" if $name !~ m/enum/;
    }
    return "$oz_phrase\n";
}

open(DECLARATIONS, ">" . $declaration_file)
    || die "Could not open file '$declaration_file' for writing. $!\n";
open(DEFINITIONS, ">" . $definition_file)
    || die "Could not open file '$definition_file' for writing. $!\n";

print DECLARATIONS "% This file was autogenerated; do not change.\n\n";
print DEFINITIONS "% This file was autogenerated; do not change.\n\n";

foreach $header (@gtk_headers) {
    open(HEADER, $header)
        || warn "Could not open header file '$header'. $!\n";

    $/ = ";"; # field separator is semicolon
    while (<HEADER>) {
        &remove_comments;
#       if (/(typedef(\s)+enum(\s)*\{)([^\}]*)\}(\s*)(\w*)/) { # select enums
        if (/(typedef(\s)+enum(\s)*\{)((\s*[^\n]*\n)+)\}([ \t\r\f]*)(\w*)/) { # select enums
            #print "$7:\n$4\n\n";
            $key_values = enum_to_hash($7, $4);
            print DEFINITIONS  gen_definitions(%$key_values);
            print DECLARATIONS gen_declarations(%$key_values);
        }
    }
    close HEADER;
}

close DECLARATIONS;
close DEFINITIONS;
